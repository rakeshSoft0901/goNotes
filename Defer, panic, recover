What is defer?
defer schedules a function to run after the surrounding function returns.

defer fmt.Println("calling in last")
fmt.Println("Hello")

Hello
calling in last

2ï¸âƒ£ When Deferred Functions Execute?
âœ” Executed after return
âœ” Executed even if panic occurs

3ï¸âƒ£ LIFO Order (STACK BEHAVIOR)
defer fmt.Println(1)
defer fmt.Println(2)
defer fmt.Println(3)
3
2
1
ğŸ“Œ Last In First Out

4ï¸âƒ£ Defer Use Cases (VERY IMPORTANT)
âœ” Closing files
âœ” Unlocking mutex
âœ” Database cleanup
âœ” Logging

file, _ := os.Open("a.txt")
defer file.Close()

5ï¸âƒ£ Defer & Return Value (INTERVIEW TRAP)
func test() int {
    x := 10
    defer func() {
        x = 20
    }()
    return x
}
o/p 10

Why?
Return value copied before defer runs.

Named Return with Defer (TRICKY)
func test() (x int) {
    defer func() {
        x = 20
    }()
    return 10
}
o/p 20
ğŸ“Œ Defer can modify named return value.

6ï¸âƒ£ What is panic?
panic stops normal execution and unwinds the stack.
panic("Something went wrong")

7ï¸âƒ£ When to Use Panic?
âœ” Programmer error
âœ” Invalid state
âœ” Unrecoverable situation
âŒ NOT for normal errors.

8ï¸âƒ£ Panic Flow

Panic occurs
Deferred functions run
Program crashes (unless recovered)

9ï¸âƒ£ What is recover?
recover catches panic and prevents program crash.

defer func() {
    if r := recover(); r != nil {
        fmt.Println("Recovered:", r)
    }
}()
ğŸ“Œ Works only inside deferred function.

ğŸ”Ÿ Recover Example
func safe() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Recovered")
        }
    }()
    panic("Crash")
}
âœ” Program continues.

1ï¸âƒ£1ï¸âƒ£ Panic + Recover Interview Trap

func test() {
    defer recover()
    panic("fail")
}
âŒ DOES NOT recover

âœ” Must be inside function:
defer func() {
    recover()
}()

1ï¸âƒ£2ï¸âƒ£ Panic in Goroutines (IMPORTANT)
go func() {
    panic("boom")
}()
âŒ Crashes entire program
âœ” Recover must be inside same goroutine

1ï¸âƒ£3ï¸âƒ£ Custom Panic Example
func divide(a, b int) int {
    if b == 0 {
        panic("divide by zero")
    }
    return a / b
}

1ï¸âƒ£4ï¸âƒ£ Defer with Loop (TRICKY)
for i := 0; i < 3; i++ {
    defer fmt.Println(i)
}
2
1
0

1ï¸âƒ£5ï¸âƒ£ Best Practices (INTERVIEW)
âœ” Use defer immediately after resource acquisition
âœ” Prefer error over panic
âœ” Recover only at program boundaries
âœ” Log panic before recover

1ï¸âƒ£6ï¸âƒ£ Common Interview Traps

âŒ Expecting recover outside defer
âŒ Using panic for validation
âŒ Forgetting LIFO order
âŒ Assuming defer executes immediately

Defer
Defer schedules a function to run after the surrounding function returns, in LIFO order.

Panic
Panic stops normal execution and begins stack unwinding.

Recover
Recover catches a panic and allows the program to continue.

ğŸ§  Quick Memory Points
Defer = delayed execution
Panic = crash
Recover = catch panic
Defer always runs
Recover only in defer


















