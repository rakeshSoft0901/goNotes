1Ô∏è‚É£ What is an Error in Go?
In Go, errors are values, not exceptions.

type error interface {
    Error() string
}
üìå Returned as the last return value.

2Ô∏è‚É£ Creating Errors
Using errors.New
err := errors.New("something went wrong")

Using fmt.Errorf
err := fmt.Errorf("failed to load")

3Ô∏è‚É£ Returning Errors (STANDARD PATTERN)
func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("divide by zero")
    }
    return a / b, nil
}
‚úî nil means no error.

4Ô∏è‚É£ Handling Errors
result, err := divide(10, 0)
if err != nil {
    return err
}
‚úî Always check error immediately.

5Ô∏è‚É£ Custom Error Types (INTERVIEW FAVORITE)
type NotFoundError struct {
    ID int
}

func (e NotFoundError) Error() string {
    return fmt.Sprintf("id %d not found", e.ID)
}

6Ô∏è‚É£ Error Wrapping (VERY IMPORTANT)
return fmt.Errorf("fetch user: %w", err)
‚úî %w wraps error
‚úî Enables error chains

7Ô∏è‚É£ Unwrapping Errors
errors.Unwrap(err)

8Ô∏è‚É£ errors.Is (INTERVIEW CRITICAL)
if errors.Is(err, ErrNotFound) {}
‚úî Works with wrapped errors.

9Ô∏è‚É£ errors.As (TYPE CHECK)
var nfErr *NotFoundError
if errors.As(err, &nfErr) {}

‚úî Extracts custom error.

üîü Sentinel Errors (COMMON)
var ErrNotFound = errors.New("not found")
‚úî Compare with errors.Is

1Ô∏è‚É£1Ô∏è‚É£ Panic vs Error (INTERVIEW)
| Error       | Panic      |
| ----------- | ---------- |
| Expected    | Unexpected |
| Recoverable | Crash      |
| Returned    | Thrown     |

üìå Prefer errors.

1Ô∏è‚É£2Ô∏è‚É£ Multiple Errors (Go 1.20+)
return errors.Join(err1, err2)
‚úî Combines multiple errors.

1Ô∏è‚É£3Ô∏è‚É£ Error Handling in Loops (TRICKY)
for _, v := range list {
    if err := process(v); err != nil {
        return err
    }
}
‚úî Use short scope.

1Ô∏è‚É£4Ô∏è‚É£ Wrapping vs Logging (INTERVIEW)

‚ùå Logging everywhere
‚úî Wrap and return
‚úî Log at top level

1Ô∏è‚É£5Ô∏è‚É£ Error with Context
return fmt.Errorf("user %d: %w", id, err)
‚úî Add meaningful info.

1Ô∏è‚É£6Ô∏è‚É£ Common Error Anti-Patterns

‚ùå Ignoring errors
‚ùå Returning generic messages
‚ùå Panic for validation
‚ùå String comparison

1Ô∏è‚É£7Ô∏è‚É£ Best Practices Summary

‚úî Errors as values
‚úî Wrap with context
‚úî Use errors.Is/As
‚úî Create typed errors
‚úî Log once

Error Handling
Go handles errors by returning them as values and checking explicitly.

Error Wrapping
Error wrapping preserves the original error while adding context.

üß† Quick Memory Points
error is interface
nil = no error
%w wraps
Is = compare
As = type assert

************************************************************************************

1Ô∏è‚É£ What is a Custom Error?
A custom error is a user-defined type that implements the error interface.

type error interface {
    Error() string
}
‚úî Any type with Error() string is an error.

2Ô∏è‚É£ Why Custom Errors?
Use custom errors when you need:
More information than a string
Error categorization
Programmatic handling
Clean API contracts

3Ô∏è‚É£ Basic Custom Error (STRUCT)

type InvalidAgeError struct {
    Age int
}

func (e InvalidAgeError) Error() string {
    return fmt.Sprintf("invalid age: %d", e.Age)
}

Usage:
return InvalidAgeError{Age: -5}

4Ô∏è‚É£ Pointer vs Value Receiver (INTERVIEW)
func (e *InvalidAgeError) Error() string {}

‚úî Use pointer receiver if:
Error has large fields
Error may be modified
Want identity consistency

5Ô∏è‚É£ Sentinel Errors vs Custom Errors
Sentinel:
var ErrNotFound = errors.New("not found")

Custom:
type NotFoundError struct {
    ID int
}
‚úî Sentinel ‚Üí simple
‚úî Custom ‚Üí rich context

6Ô∏è‚É£ Wrapping Custom Errors (CRITICAL)
return fmt.Errorf("fetch user: %w", NotFoundError{ID: 10})
‚úî Preserves original error.

7Ô∏è‚É£ Checking Custom Errors (errors.As)
var nfErr *NotFoundError
if errors.As(err, &nfErr) {
    fmt.Println(nfErr.ID)
}
‚úî Safest way
‚úî Works with wrapping

8Ô∏è‚É£ Using errors.Is with Custom Errors
Implement Is
func (e NotFoundError) Is(target error) bool {
    _, ok := target.(NotFoundError)
    return ok
}
‚úî Enables category matching.

9Ô∏è‚É£ Typed Error with Code (PRODUCTION)
type AppError struct {
    Code    string
    Message string
}

func (e AppError) Error() string {
    return e.Message
}

return AppError{
    Code: "USER_NOT_FOUND",
    Message: "user does not exist",
}

üîü Custom Error + HTTP Status (VERY COMMON)

type HTTPError struct {
    Status int
    Err    error
}

func (e HTTPError) Error() string {
    return e.Err.Error()
}
Usage:
return HTTPError{
    Status: 404,
    Err: ErrNotFound,
}


1Ô∏è‚É£1Ô∏è‚É£ Validation Errors (FIELD LEVEL)
type ValidationError struct {
    Field string
    Msg   string
}

func (e ValidationError) Error() string {
    return fmt.Sprintf("%s: %s", e.Field, e.Msg)
}
‚úî Used in APIs.

1Ô∏è‚É£2Ô∏è‚É£ Multiple Custom Errors (Go 1.20+)
return errors.Join(
    ValidationError{"email", "invalid"},
    ValidationError{"age", "too low"},
)

1Ô∏è‚É£3Ô∏è‚É£ Error Wrapping Best Practice
‚ùå return errors.New("failed")
‚úÖ return fmt.Errorf("save user %d: %w", id, err)

1Ô∏è‚É£4Ô∏è‚É£ Custom Errors + Context
return fmt.Errorf("request %s: %w", reqID, err)
‚úî Adds traceability.

1Ô∏è‚É£5Ô∏è‚É£ Common Traps (INTERVIEW)

‚ùå Comparing errors with ==
‚ùå String matching
‚ùå Overusing panic
‚ùå Returning internal errors to clients

1Ô∏è‚É£6Ô∏è‚É£ Clean Error Design (ARCHITECTURE)
Layered approach:
Domain errors
Service errors
Transport errors
‚úî Each layer wraps errors.

Custom Error
A custom error is a user-defined type implementing the error interface to provide richer context.

errors.As
errors.As extracts a specific error type from a wrapped error chain.





