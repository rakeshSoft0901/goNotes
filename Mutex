What is a Mutex?
A mutex (mutual exclusion lock) ensures that only one goroutine can access a shared resource at a time.
ğŸ“Œ Prevents race conditions.

2ï¸âƒ£ Why Mutex is Needed?
count := 0

go func() { count++ }()
go func() { count++ }()

âŒ Race condition
âœ” Mutex ensures safe access.

3ï¸âƒ£ Import Package
import "sync"

4ï¸âƒ£ Basic Mutex Usage
var mu sync.Mutex
count := 0

go func() {
    mu.Lock()
    count++
    mu.Unlock()
}()
âœ” Lock before critical section
âœ” Unlock after

5ï¸âƒ£ Always Use defer Unlock() (BEST PRACTICE)
mu.Lock()
defer mu.Unlock()
âœ” Prevents deadlocks on panic/return.

6ï¸âƒ£ Mutex with Struct (COMMON)
type Counter struct {
    mu    sync.Mutex
    value int
}

func (c *Counter) Inc() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.value++
}

7ï¸âƒ£ RWMutex (INTERVIEW FAVORITE)
What is RWMutex?
Allows:
  Multiple readers
  One writer

var mu sync.RWMutex

Read Lock
mu.RLock()
defer mu.RUnlock()

Write Lock
mu.Lock()
defer mu.Unlock()
ğŸ“Œ Writers block readers & writers.

8ï¸âƒ£ When to Use RWMutex?

âœ” Many reads
âœ” Few writes
âŒ Heavy writes â†’ slower

9ï¸âƒ£ Mutex vs Channel (INTERVIEW)
Mutex	                              Channel
Shared memory                      	Message passing
Low overhead                      	More readable
Critical section                  	Data flow
ğŸ“Œ Go proverb prefers channels, but mutex is fine.

ğŸ”Ÿ Deadlock (VERY IMPORTANT)
mu.Lock()
mu.Lock() // âŒ deadlock
âœ” Same goroutine cannot lock twice.

1ï¸âƒ£1ï¸âƒ£ Common Deadlock Scenarios
âŒ Forgetting Unlock
âŒ Lock order inversion
âŒ Goroutine waiting forever

1ï¸âƒ£2ï¸âƒ£ Mutex is NOT Reentrant (INTERVIEW)
func f() {
    mu.Lock()
    g()
    mu.Unlock()
}

func g() {
    mu.Lock() // âŒ deadlock
}

1ï¸âƒ£3ï¸âƒ£ Mutex Zero Value
var mu sync.Mutex
âœ” Ready to use
âŒ Do not copy after use.

1ï¸âƒ£4ï¸âƒ£ Copying Mutex (INTERVIEW TRAP)
type Data struct {
    mu sync.Mutex
}
âŒ Copying Data after use â†’ undefined behavior.

1ï¸âƒ£5ï¸âƒ£ Mutex Performance Notes

âœ” Very fast
âœ” Avoid long critical sections
âœ” Lock only what you need

1ï¸âƒ£6ï¸âƒ£ Atomic vs Mutex (INTERVIEW)
atomic.AddInt64(&x, 1)

Atomic	                        Mutex
Single variable	                Multiple variables
Faster	                        Flexible
Limited operations	            Complex logic

1ï¸âƒ£7ï¸âƒ£ Common Interview Traps

âŒ Forgetting defer unlock
âŒ Copying mutex
âŒ Overusing mutex
âŒ Using mutex inside goroutine without exit

Mutex
A mutex ensures mutual exclusion so only one goroutine accesses shared data at a time.

RWMutex
RWMutex allows multiple readers but only one writer.

ğŸ§  Quick Memory Points

Mutex = lock
Use defer unlock
Zero value usable
Not reentrant
Avoid copying
















