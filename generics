1ï¸âƒ£ What are Generics?
Generics allow you to write type-safe, reusable code that works with multiple types.
ğŸ“Œ Introduced in Go 1.18

2ï¸âƒ£ Why Generics Were Needed?

Before generics:
Code duplication
interface{} + type assertions
Runtime errors
Generics solve this at compile time.

3ï¸âƒ£ Basic Generic Function
func Print[T any](value T) {
    fmt.Println(value)
}

Usage:
Print
Print("Go")
âœ” Type inference works

4ï¸âƒ£ Type Parameters Syntax
[T any]

T â†’ type parameter
any â†’ alias for interface{}

5ï¸âƒ£ Generic with Multiple Types
func Pair[A any, B any](a A, b B) {
    fmt.Println(a, b)
}

6ï¸âƒ£ Constraints (VERY IMPORTANT)
Using constraints package

import "golang.org/x/exp/constraints"

func Sum[T constraints.Integer](a, b T) T {
    return a + b
}
âœ” Restricts allowed types

7ï¸âƒ£ Custom Constraints (INTERVIEW FAVORITE)
type Number interface {
    int | int64 | float64
}

func Add[T Number](a, b T) T {
    return a + b
}
âœ” Union types

8ï¸âƒ£ Comparable Constraint
func Equal[T comparable](a, b T) bool {
    return a == b
}
ğŸ“Œ comparable is built-in

9ï¸âƒ£ Generic Struct
type Box[T any] struct {
    Value T
}

Usage:
b := Box[int]{Value: 10}

ğŸ”Ÿ Generic Methods (TRICKY)
type Stack[T any] struct {
    items []T
}

func (s *Stack[T]) Push(v T) {
    s.items = append(s.items, v)
}
ğŸ“Œ Methods use the same type parameter

1ï¸âƒ£1ï¸âƒ£ Generic Interface (LIMITED)

type Store[T any] interface {
    Save(T)
}
âœ” Allowed
âŒ Cannot have type parameters on methods alone

1ï¸âƒ£2ï¸âƒ£ Type Inference (IMPORTANT)
Add(10, 20)   // compiler infers T = int
âœ” Explicit type often unnecessary

1ï¸âƒ£3ï¸âƒ£ Underlying Type (~) (ADVANCED)
type MyInt int

type Number interface {
    ~int | ~int64
}
âœ” Accepts custom types

1ï¸âƒ£4ï¸âƒ£ Generic Slice Helpers (COMMON)
func Map[T any, R any](s []T, fn func(T) R) []R {
    r := make([]R, len(s))
    for i, v := range s {
        r[i] = fn(v)
    }
    return r
}

1ï¸âƒ£5ï¸âƒ£ Generics vs Interfaces (INTERVIEW)
Generics	                Interfaces
Compile-time	            Runtime
Type-safe	                Dynamic
Data structures	          Behavior
ğŸ“Œ Use both together

1ï¸âƒ£6ï¸âƒ£ What Generics CANNOT Do (TRAPS)
âŒ No operator overloading
âŒ No specialization
âŒ No generic constants
âŒ No higher-kinded types

1ï¸âƒ£7ï¸âƒ£ Zero Value of Type Parameter
var zero T
âœ” Works for any type

1ï¸âƒ£8ï¸âƒ£ Performance (INTERVIEW)
âœ” No boxing
âœ” No reflection
âœ” Near hand-written code speed

ğŸ“Œ Generics are monomorphized

1ï¸âƒ£9ï¸âƒ£ When to Use Generics?

âœ” Data structures
âœ” Algorithms
âœ” Utilities
âœ” Libraries

2ï¸âƒ£0ï¸âƒ£ When NOT to Use Generics?

âŒ Single type
âŒ Behavior-based logic
âŒ Premature abstraction

2ï¸âƒ£1ï¸âƒ£ Common Interview Traps

âŒ Overusing generics
âŒ Using any instead of constraints
âŒ Forgetting ~ for custom types
âŒ Confusing generics with interfaces

Generics
Generics allow writing reusable, type-safe code using type parameters evaluated at compile time.

Constraints
Constraints restrict the set of types allowed for a type parameter.

ğŸ§  Quick Memory Points
[T any]
Constraints = type sets
comparable
~ for underlying types
Compile-time safety



































